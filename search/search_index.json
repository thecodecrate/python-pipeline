{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TheCodeCrate's Pipeline","text":"<p>This package provides a pipeline pattern implementation.</p> <p>The implementation is inspired by the excellent PHP League Pipeline package.</p> <p>Full documentation can be found at https://thecodecrate.github.io/python-pipeline/.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install thecodecrate-pipeline\n</code></pre>"},{"location":"#pipeline-pattern","title":"Pipeline Pattern","text":"<p>The pipeline pattern allows you to easily compose sequential stages by chaining stages.</p> <p>In this particular implementation, the interface consists of two parts:</p> <ul> <li><code>StageInterface</code></li> <li><code>PipelineInterface</code></li> </ul> <p>A pipeline consists of zero, one, or multiple stages. A pipeline can process a payload. During the processing, the payload will be passed to the first stage. From that moment on, the resulting value is passed on from stage to stage.</p> <p>In the simplest form, the execution chain can be represented as a for loop:</p> <pre><code>result = payload\n\nfor stage in stages:\n    result = stage(result)\n\nreturn result\n</code></pre> <p>Effectively, this is the same as:</p> <pre><code>result = stage3(stage2(stage1(payload)))\n</code></pre>"},{"location":"#immutability","title":"Immutability","text":"<p>Pipelines are implemented as immutable stage chains. When you pipe a new stage, a new pipeline will be created with the added stage. This makes pipelines easy to reuse and minimizes side-effects.</p>"},{"location":"#usage","title":"Usage","text":"<p>Operations in a pipeline, stages, can be anything that satisfies the <code>Callable</code> type hint. So functions and anything that's callable is acceptable.</p> <pre><code>pipeline = Pipeline().pipe(lambda payload: payload * 10)\n\n# Returns 100\nawait pipeline.process(10)\n</code></pre>"},{"location":"#class-based-stages","title":"Class-Based Stages","text":"<p>Class-based stages are also possible. The <code>StageInterface[T_in, T_out]</code> interface can be implemented, which ensures you have the correct method signature for the <code>__call__</code> method.</p> <pre><code>class TimesTwoStage(StageInterface[int, int]):\n    async def __call__(self, payload: int) -&gt; int:\n        return payload * 2\n\nclass AddOneStage(StageInterface[int, int]):\n    async def __call__(self, payload: int) -&gt; int:\n        return payload + 1\n\npipeline = (\n    Pipeline[int, int]()\n    .pipe(TimesTwoStage())\n    .pipe(AddOneStage())\n)\n\n# Returns 21\nawait pipeline.process(10)\n</code></pre>"},{"location":"#reusable-pipelines","title":"Reusable Pipelines","text":"<p>Because the <code>PipelineInterface</code> is an extension of the <code>StageInterface</code>, pipelines can be reused as stages. This creates a highly composable model to create complex execution patterns while keeping the cognitive load low.</p> <p>For example, if we'd want to compose a pipeline to process API calls, we'd create something along these lines:</p> <pre><code>process_api_request = (\n    Pipeline()\n    .pipe(ExecuteHttpRequest())\n    .pipe(ParseJsonResponse())\n)\n\npipeline = (\n    Pipeline()\n    .pipe(ConvertToPsr7Request())\n    .pipe(process_api_request)\n    .pipe(ConvertToResponseDto())\n)\n\nawait pipeline.process(DeleteBlogPost(post_id))\n</code></pre>"},{"location":"#type-hinting","title":"Type Hinting","text":"<p>You can specify the input and output types for pipelines and stages using type variables <code>T_in</code> and <code>T_out</code>. This allows you to handle varying types between stages, enhancing type safety and code clarity.</p> <p>The <code>T_out</code> type variable is optional and defaults to <code>T_in</code>. Similarly, <code>T_in</code> is also optional and defaults to <code>Any</code>.</p> <pre><code>from typing import Any\n\npipeline = Pipeline[int]().pipe(lambda payload: payload * 2)\n\n# Returns 20\nawait pipeline.process(10)\n</code></pre> <p>You can also handle varying types between stages:</p> <pre><code>pipeline = Pipeline[int, str]().pipe(lambda payload: f\"Number: {payload}\")\n\n# Returns \"Number: 10\"\nawait pipeline.process(10)\n</code></pre> <p>This flexibility allows you to build pipelines that transform data types between stages seamlessly.</p>"},{"location":"#custom-processors","title":"Custom Processors","text":"<p>You can create your own processors to customize how the pipeline processes stages. This allows you to implement different execution strategies, such as handling exceptions, processing resources, or implementing middleware patterns.</p> <p>For example, you can define a custom processor:</p> <pre><code>class MyCustomProcessor(Processor[T_in, T_out]):\n    async def process(\n        self,\n        payload: T_in,\n        stages: StageInstanceCollection,\n    ) -&gt; T_out:\n        # Custom processing logic\n        for stage in stages:\n            payload = await stage(payload)\n        return payload\n</code></pre> <p>And use it in your pipeline:</p> <pre><code>pipeline = Pipeline[int, int](processor=MyCustomProcessor()).pipe(lambda x: x * 2)\n</code></pre>"},{"location":"#declarative-stages","title":"Declarative Stages","text":"<p>Instead of using <code>pipe</code> to add stages at runtime, you can define stages declaratively by specifying them as class-level attributes. This makes pipelines easier to set up and reuse with predefined stages.</p> <pre><code>class MyPipeline(Pipeline[int, int]):\n    stages = [\n        TimesTwoStage(),\n        TimesThreeStage(),\n    ]\n\n# Process the payload through the pipeline with the declared stages\nresult = await MyPipeline().process(5)\n\n# Returns 30\nprint(result)\n</code></pre> <p>In this example, <code>MyPipeline</code> declares its stages directly in the class definition, making the pipeline setup more readable and maintainable.</p>"},{"location":"#declarative-processor","title":"Declarative Processor","text":"<p>You can also specify the processor in a declarative way by setting the <code>processor_class</code> attribute in your pipeline class.</p> <pre><code>class MyPipeline(Pipeline[T_in, T_out]):\n    processor_class = MyCustomProcessor\n</code></pre> <p>This allows you to customize the processing behavior of your pipeline while keeping the definition clean and declarative.</p>"},{"location":"#processing-streams","title":"Processing Streams","text":"<p>The pipeline can also process streams in real-time, allowing you to handle asynchronous iterators and process data as it becomes available.</p> <pre><code>from typing import AsyncIterator\nimport asyncio\n\nasync def input_stream() -&gt; AsyncIterator[int]:\n    for i in range(5):\n        yield i\n\nasync def stage1(stream: AsyncIterator[int]) -&gt; AsyncIterator[int]:\n    async for item in stream:\n        yield item * 2\n        await asyncio.sleep(1)  # Simulate processing delay\n\nasync def stage2(stream: AsyncIterator[int]) -&gt; AsyncIterator[str]:\n    async for item in stream:\n        yield f\"Number: {item}\"\n\n\nasync def main():\n    pipeline = (\n        Pipeline[AsyncIterator[int], AsyncIterator[str]]()\n        .pipe(stage1)\n        .pipe(stage2)\n    )\n\n    stream = await pipeline.process(input_stream())\n\n    async for result in stream:\n        print(result)\n\n# Run the async main function\nawait main()\n</code></pre> <p>This allows you to process data in a streaming fashion, where each stage can yield results that are immediately consumed by the next stage.</p>"},{"location":"#pipeline-factory","title":"Pipeline Factory","text":"<p>Because pipelines themselves are immutable, pipeline factory is introduced to facilitate distributed composition of a pipeline.</p> <p>The <code>PipelineFactory[InputType, OutputType]</code> collects stages and allows you to create a pipeline at any given time.</p> <pre><code>pipeline_factory = PipelineFactory().with_stages([LogicalStage(), AddOneStage()])\n\n# Additional stages can be added later\npipeline_factory.add_stage(LastStage()).with_processor(MyCustomProcessor())\n\n# Build the pipeline\npipeline = pipeline_factory.build()\n</code></pre>"},{"location":"#exception-handling","title":"Exception Handling","text":"<p>This package is completely transparent when dealing with exceptions. In no case will this package catch an exception or silence an error. Exceptions should be dealt with on a per-case basis, either inside a stage or at the time the pipeline processes a payload.</p> <pre><code>pipeline = Pipeline().pipe(lambda payload: payload / 0)\n\ntry:\n    await pipeline.process(10)\nexcept ZeroDivisionError as e:\n    # Handle the exception.\n    pass\n</code></pre>"},{"location":"#architecture","title":"Architecture","text":"<p>All code is located in the <code>src/_api</code> directory and follows the Static-Plugin Design (SPD) pattern. This architectural approach ensures:</p> <ul> <li>Clear separation of concerns through static plugins</li> <li>Full static analysis capabilities</li> <li>Predictable code execution paths</li> <li>Zero runtime overhead</li> </ul> <p>The project utilizes class composition rather than dynamic plugins, making the codebase easier to maintain and debug while preserving extensibility.</p>"},{"location":"#projects-specs-and-guidelines","title":"Project's Specs and Guidelines","text":"<ul> <li>spec2: Static-Plugin Design</li> <li>spec3: SPD Manifest Files</li> <li>spec4: SPD Naming Convention</li> </ul>"},{"location":"api/core/","title":"API Reference","text":""},{"location":"api/core/#thecodecrate_pipeline","title":"thecodecrate_pipeline","text":""},{"location":"api/core/#thecodecrate_pipeline.Pipeline","title":"Pipeline","text":"<pre><code>Pipeline(\n    processor_class: Optional[\n        type[ProcessorInterface]\n    ] = None,\n    processor_instance: Optional[ProcessorInterface] = None,\n    processor: Optional[\n        type[ProcessorInterface] | ProcessorInterface\n    ] = None,\n    *args: Any,\n    **kwds: Any,\n)\n</code></pre> <p>Pipeline Class</p>"},{"location":"api/core/#thecodecrate_pipeline.Pipeline.processor_class","title":"processor_class  <code>instance-attribute</code>","text":"<pre><code>processor_class: Optional[\n    type[ProcessorInterface[T_in, T_out]]\n]\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.Pipeline.processor_instance","title":"processor_instance  <code>instance-attribute</code>","text":"<pre><code>processor_instance: Optional[\n    ProcessorInterface[T_in, T_out]\n]\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.Pipeline.stage_instances","title":"stage_instances  <code>instance-attribute</code>","text":"<pre><code>stage_instances: StageInstanceCollection\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.Pipeline.stages","title":"stages  <code>instance-attribute</code>","text":"<pre><code>stages: StageCollection\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.Pipeline.clone","title":"clone","text":"<pre><code>clone(attributes: dict[str, Any]) -&gt; Self\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.Pipeline.get_processor_class","title":"get_processor_class","text":"<pre><code>get_processor_class() -&gt; Optional[type[ProcessorInterface]]\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.Pipeline.get_processor_instance","title":"get_processor_instance","text":"<pre><code>get_processor_instance() -&gt; Optional[ProcessorInterface]\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.Pipeline.pipe","title":"pipe","text":"<pre><code>pipe(stage: StageInstance) -&gt; Self\n</code></pre> <p>Adds a single stage to the pipeline.</p>"},{"location":"api/core/#thecodecrate_pipeline.Pipeline.process","title":"process  <code>async</code>","text":"<pre><code>process(payload: T_in, *args: Any, **kwds: Any) -&gt; T_out\n</code></pre> <p>Process the given payload through the pipeline.</p>"},{"location":"api/core/#thecodecrate_pipeline.Pipeline.with_processor","title":"with_processor","text":"<pre><code>with_processor(\n    processor: (\n        type[ProcessorInterface] | ProcessorInterface\n    ),\n) -&gt; Self\n</code></pre> <p>Attachs a processor (class or instance) to the pipeline.</p>"},{"location":"api/core/#thecodecrate_pipeline.Pipeline.with_processor_class","title":"with_processor_class","text":"<pre><code>with_processor_class(\n    processor_class: type[ProcessorInterface],\n) -&gt; Self\n</code></pre> <p>Attachs a processor class to the pipeline.</p>"},{"location":"api/core/#thecodecrate_pipeline.Pipeline.with_processor_instance","title":"with_processor_instance","text":"<pre><code>with_processor_instance(\n    processor_instance: ProcessorInterface,\n) -&gt; Self\n</code></pre> <p>Attachs a processor instance to the pipeline.</p>"},{"location":"api/core/#thecodecrate_pipeline.Pipeline.with_stages","title":"with_stages","text":"<pre><code>with_stages(stages: StageCollection) -&gt; Self\n</code></pre> <p>Adds a collection of stages to the pipeline.</p>"},{"location":"api/core/#thecodecrate_pipeline.PipelineFactory","title":"PipelineFactory","text":"<pre><code>PipelineFactory(\n    processor_class: Optional[\n        type[ProcessorInterface]\n    ] = None,\n    processor_instance: Optional[ProcessorInterface] = None,\n    processor: Optional[\n        type[ProcessorInterface] | ProcessorInterface\n    ] = None,\n    *args: Any,\n    **kwds: Any,\n)\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.PipelineFactory.pipeline_class","title":"pipeline_class  <code>instance-attribute</code>","text":"<pre><code>pipeline_class: Optional[type[TPipeline]]\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.PipelineFactory.processor_class","title":"processor_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>processor_class: Optional[\n    type[ProcessorInterface[T_in, T_out]]\n] = None\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.PipelineFactory.processor_instance","title":"processor_instance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>processor_instance: Optional[\n    ProcessorInterface[T_in, T_out]\n] = None\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.PipelineFactory.stages","title":"stages  <code>instance-attribute</code>","text":"<pre><code>stages: StageCollection\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.PipelineFactory.add_stage","title":"add_stage","text":"<pre><code>add_stage(stage: StageClassOrInstance) -&gt; Self\n</code></pre> <p>Adds a single stage to the pipeline.</p>"},{"location":"api/core/#thecodecrate_pipeline.PipelineFactory.make","title":"make","text":"<pre><code>make() -&gt; TModel\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.PipelineFactory.with_processor","title":"with_processor","text":"<pre><code>with_processor(\n    processor: (\n        type[ProcessorInterface] | ProcessorInterface\n    ),\n) -&gt; Self\n</code></pre> <p>Attachs a processor (class or instance) to the pipeline factory.</p>"},{"location":"api/core/#thecodecrate_pipeline.PipelineFactory.with_processor_class","title":"with_processor_class","text":"<pre><code>with_processor_class(\n    processor_class: type[ProcessorInterface],\n) -&gt; Self\n</code></pre> <p>Attachs a processor class to the pipeline factory.</p>"},{"location":"api/core/#thecodecrate_pipeline.PipelineFactory.with_processor_instance","title":"with_processor_instance","text":"<pre><code>with_processor_instance(\n    processor_instance: ProcessorInterface,\n) -&gt; Self\n</code></pre> <p>Attachs a processor instance to the pipeline factory.</p>"},{"location":"api/core/#thecodecrate_pipeline.PipelineFactory.with_stages","title":"with_stages","text":"<pre><code>with_stages(stages: StageCollection) -&gt; Self\n</code></pre> <p>Adds a collection of stages to the pipeline.</p>"},{"location":"api/core/#thecodecrate_pipeline.PipelineFactoryInterface","title":"PipelineFactoryInterface","text":"<pre><code>PipelineFactoryInterface(\n    processor_class: Optional[\n        type[ProcessorInterface]\n    ] = None,\n    processor_instance: Optional[ProcessorInterface] = None,\n    processor: Optional[\n        type[ProcessorInterface] | ProcessorInterface\n    ] = None,\n    *args: Any,\n    **kwds: Any,\n)\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.PipelineFactoryInterface.add_stage","title":"add_stage","text":"<pre><code>add_stage(stage: StageClassOrInstance) -&gt; Self\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.PipelineFactoryInterface.make","title":"make","text":"<pre><code>make() -&gt; Any\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.PipelineFactoryInterface.with_processor","title":"with_processor","text":"<pre><code>with_processor(\n    processor: (\n        type[ProcessorInterface] | ProcessorInterface\n    ),\n) -&gt; Self\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.PipelineFactoryInterface.with_processor_class","title":"with_processor_class","text":"<pre><code>with_processor_class(\n    processor_class: type[ProcessorInterface],\n) -&gt; Self\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.PipelineFactoryInterface.with_processor_instance","title":"with_processor_instance","text":"<pre><code>with_processor_instance(\n    processor_instance: ProcessorInterface,\n) -&gt; Self\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.PipelineFactoryInterface.with_stages","title":"with_stages","text":"<pre><code>with_stages(stages: StageCollection) -&gt; Self\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.PipelineInterface","title":"PipelineInterface","text":"<pre><code>PipelineInterface(\n    processor_class: Optional[\n        type[ProcessorInterface]\n    ] = None,\n    processor_instance: Optional[ProcessorInterface] = None,\n    processor: Optional[\n        type[ProcessorInterface] | ProcessorInterface\n    ] = None,\n    *args: Any,\n    **kwds: Any,\n)\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.PipelineInterface.clone","title":"clone","text":"<pre><code>clone(attributes: dict[str, Any]) -&gt; Self\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.PipelineInterface.get_processor_class","title":"get_processor_class","text":"<pre><code>get_processor_class() -&gt; Optional[type[ProcessorInterface]]\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.PipelineInterface.get_processor_instance","title":"get_processor_instance","text":"<pre><code>get_processor_instance() -&gt; Optional[ProcessorInterface]\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.PipelineInterface.pipe","title":"pipe","text":"<pre><code>pipe(stage: StageInstance) -&gt; Self\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.PipelineInterface.process","title":"process  <code>async</code>","text":"<pre><code>process(payload: T_in, *args: Any, **kwds: Any) -&gt; T_out\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.PipelineInterface.with_processor","title":"with_processor","text":"<pre><code>with_processor(\n    processor: (\n        type[ProcessorInterface] | ProcessorInterface\n    ),\n) -&gt; Self\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.PipelineInterface.with_processor_class","title":"with_processor_class","text":"<pre><code>with_processor_class(\n    processor_class: type[ProcessorInterface],\n) -&gt; Self\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.PipelineInterface.with_processor_instance","title":"with_processor_instance","text":"<pre><code>with_processor_instance(\n    processor_instance: ProcessorInterface,\n) -&gt; Self\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.PipelineInterface.with_stages","title":"with_stages","text":"<pre><code>with_stages(stages: StageCollection) -&gt; Self\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.Processor","title":"Processor","text":"<pre><code>Processor(*args: Any, **kwds: Any)\n</code></pre> <p>Processor Class</p>"},{"location":"api/core/#thecodecrate_pipeline.Processor.clone","title":"clone","text":"<pre><code>clone(attributes: dict[str, Any]) -&gt; Self\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.Processor.process","title":"process  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>process(\n    payload: T_in,\n    stages: StageInstanceCollection,\n    *args: Any,\n    **kwds: Any,\n) -&gt; T_out\n</code></pre> <p>Process the given payload through the provided stages.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>T_out</code> (              <code>T_out</code> )          \u2013            <p>The processed output.</p> </li> </ul>"},{"location":"api/core/#thecodecrate_pipeline.Processor.process(payload)","title":"<code>payload</code>","text":"(<code>T_in</code>)           \u2013            <p>The input payload to process.</p>"},{"location":"api/core/#thecodecrate_pipeline.Processor.process(stages)","title":"<code>stages</code>","text":"(<code>StageInstanceCollection</code>)           \u2013            <p>The collection of stages to process the payload through.</p>"},{"location":"api/core/#thecodecrate_pipeline.Processor.process(*args)","title":"<code>*args</code>","text":"(<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Additional positional arguments.</p>"},{"location":"api/core/#thecodecrate_pipeline.Processor.process(**kwds)","title":"<code>**kwds</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments.</p>"},{"location":"api/core/#thecodecrate_pipeline.ProcessorInterface","title":"ProcessorInterface","text":"<pre><code>ProcessorInterface(*args: Any, **kwds: Any)\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.ProcessorInterface.clone","title":"clone","text":"<pre><code>clone(attributes: dict[str, Any]) -&gt; Self\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.ProcessorInterface.process","title":"process  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>process(\n    payload: T_in,\n    stages: StageInstanceCollection,\n    *args: Any,\n    **kwds: Any,\n) -&gt; T_out\n</code></pre>"},{"location":"api/core/#thecodecrate_pipeline.Stage","title":"Stage","text":""},{"location":"api/core/#thecodecrate_pipeline.StageCallable","title":"StageCallable","text":""},{"location":"api/core/#thecodecrate_pipeline.StageInterface","title":"StageInterface","text":""},{"location":"api/processors/","title":"API Reference","text":""},{"location":"api/processors/#thecodecrate_pipeline.processors","title":"processors","text":"<p>A collection of processors and their pipelines</p>"},{"location":"api/processors/#thecodecrate_pipeline.processors.ChainedPipeline","title":"ChainedPipeline","text":"<pre><code>ChainedPipeline(*args: Any, **kwargs: Any)\n</code></pre> <p>Default pipeline (<code>Pipeline</code> alias). Sequentially processes data through multiple stages.</p> Example <pre><code># Process data through multiple stages\npipeline = (\n    (ChainedPipeline[int]())\n    .pipe(lambda payload: payload + 1)\n    .pipe(lambda payload: payload * 2)\n    .pipe(lambda payload: payload + 1)\n)\n\n# Assert result\nassert await pipeline.process(1) == 5\n</code></pre>"},{"location":"api/processors/#thecodecrate_pipeline.processors.ChainedProcessor","title":"ChainedProcessor","text":"<p>Default processor. Sequentially processes data through multiple stages.</p> Example <pre><code># Create processor\nprocessor = ChainedProcessor[int]()\n\n# Stages\nresult = await processor.process(\n    payload=5,\n    stages=(\n        lambda payload: payload + 1,\n        lambda payload: payload * 2,\n    ),\n)\n\n# Assert result\nassert result == 12\n</code></pre>"},{"location":"api/processors/#thecodecrate_pipeline.processors.InterruptiblePipeline","title":"InterruptiblePipeline","text":"<pre><code>InterruptiblePipeline(\n    check: CheckCallable, *args: Any, **kwargs: Any\n)\n</code></pre> <p>Pipeline with conditional interruption.</p> <p>Parameters:</p> Example <pre><code># Interrupts when payload value exceeds 100\npipeline = (\n    InterruptiblePipeline[int](lambda payload: payload &gt; 100)\n    .pipe(lambda payload: payload + 2)\n    .pipe(lambda payload: payload * 10)\n    .pipe(lambda payload: payload * 10)\n)\n\n# Process payload - will stop if value exceeds 100\nassert await pipeline.process(5) == 70\n</code></pre>"},{"location":"api/processors/#thecodecrate_pipeline.processors.InterruptiblePipeline(check)","title":"<code>check</code>","text":"(<code>CheckCallable</code>)           \u2013            <p>Callable used to interrupt processing.</p>"},{"location":"api/processors/#thecodecrate_pipeline.processors.InterruptibleProcessor","title":"InterruptibleProcessor","text":"<pre><code>InterruptibleProcessor(check: CheckCallable[T_in])\n</code></pre> <p>Processor with conditional interruption.</p> <p>Parameters:</p> Example <pre><code># Interrupts when payload value exceeds 100\ndef check_value(payload: int) -&gt; bool:\n    return payload &gt; 100\n\n# Create processor with the check\nprocessor = InterruptibleProcessor(check_value)\n\n# Process payload - will stop if value exceeds 100\nresult = await processor.process(initial_payload, stages)\n</code></pre>"},{"location":"api/processors/#thecodecrate_pipeline.processors.InterruptibleProcessor(check)","title":"<code>check</code>","text":"(<code>CheckCallable[T_in]</code>)           \u2013            <p>Callable for processing interruption.</p>"},{"location":"api/processors/#thecodecrate_pipeline.processors.InterruptibleProcessor.check","title":"check  <code>instance-attribute</code>","text":"<pre><code>check: CheckCallable[T_in] = check\n</code></pre> <p>Callable for processing interruption. Useful for declarative subclassing.</p> Example <pre><code>class MaxValueProcessor(InterruptibleProcessor[int, int]):\n    # interrupt if value exceeds 100\n    check = lambda x: x &gt; 100\n</code></pre>"},{"location":"api/types/","title":"API Reference","text":""},{"location":"api/types/#thecodecrate_pipeline.types","title":"types","text":"<p>Library's public types</p>"},{"location":"api/types/#thecodecrate_pipeline.types.StageClassOrInstance","title":"StageClassOrInstance  <code>module-attribute</code>","text":"<pre><code>StageClassOrInstance = StageInstance | type[StageInstance]\n</code></pre> <p>Stage class or object</p>"},{"location":"api/types/#thecodecrate_pipeline.types.StageCollection","title":"StageCollection  <code>module-attribute</code>","text":"<pre><code>StageCollection = tuple[StageClassOrInstance, ...]\n</code></pre> <p>Collection of Stage classes or objects</p>"},{"location":"api/types/#thecodecrate_pipeline.types.StageInstance","title":"StageInstance  <code>module-attribute</code>","text":"<pre><code>StageInstance = StageCallable\n</code></pre> <p>Stage object</p>"},{"location":"api/types/#thecodecrate_pipeline.types.StageInstanceCollection","title":"StageInstanceCollection  <code>module-attribute</code>","text":"<pre><code>StageInstanceCollection = tuple[StageInstance, ...]\n</code></pre> <p>Collection of Stage objects</p>"},{"location":"api/types/#thecodecrate_pipeline.types.T_in","title":"T_in  <code>module-attribute</code>","text":"<pre><code>T_in = TypeVar('T_in', default=Any, infer_variance=True)\n</code></pre> <p>Input data type for pipeline flow (payload's value type)</p>"},{"location":"api/types/#thecodecrate_pipeline.types.T_out","title":"T_out  <code>module-attribute</code>","text":"<pre><code>T_out = TypeVar('T_out', default=T_in, infer_variance=True)\n</code></pre> <p>Output data type for pipeline flow (result's value type)</p>"}]}